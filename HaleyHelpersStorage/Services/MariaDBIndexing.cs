using Haley.Abstractions;
using Haley.Enums;
using Haley.Models;
using Haley.Utils;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using static Haley.Internal.IndexingConstant;
using static Haley.Internal.IndexingQueries;

namespace Haley.Utils {
    public class MariaDBIndexing : IDSSIndexing {
        const string DB_CORE_SQL_FILE = "dsscore.sql";
        const string DB_CLIENT_SQL_FILE = "dssclient.sql";
        const string DB_CORE_FALLBACK_NAME = "mss_core";
        const string DB_CORE_SEARCH_TERM = "dss_core";
        const string DB_CLIENT_SEARCH_TERM = "dss_client";
        const string DB_SQL_FILE_LOCATION = "Resources";
        const string DB_MODULE_NAME_PREFIX = "dssm_";
        string _key;
        IAdapterGateway _agw;
        bool isValidated = false;
        async Task EnsureValidation() {
            if (!isValidated) await Validate();
        }

        ConcurrentDictionary<string, IOSSDirectory> _idxAllDirectories = new ConcurrentDictionary<string, IOSSDirectory>();
        public async Task<IFeedback> RegisterClient(IOSSClient info) {
            if (info == null) throw new ArgumentNullException("Input client directory info cannot be null");
            if (!info.TryValidate(out var msg)) throw new ArgumentException(msg);
            //We generate the hash_guid ourselves for the client.
            await EnsureValidation();

            //Do we even need to check if the client exists? Why dont' we directly upsert the values??? We need to check, because, if we try upsert, then each time , we end up with a new autogenerated id that is not consumed. So, we might end up with all ids' consumed in years. For safer side, we use upsert, also, we check if id exists and try to update separately.

            var exists = await _agw.Scalar(new AdapterArgs(_key) { Query = CLIENT.EXISTS }, (NAME, info.Name));
            var thandler = _agw.GetTransactionHandler(_key); //For both cases, update or upsert, we use inside a transaction.
            if (exists != null && exists is int cliId) {
                //Client exists. We just need to update.
                using (thandler.Begin()) {
                    //Register client
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPDATE }).ForTransaction(thandler), (DNAME, info.DisplayName), (PATH, info.Path),(ID, cliId));
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERTKEYS }).ForTransaction(thandler), (ID, cliId), (SIGNKEY, info.SigningKey), (ENCRYPTKEY, info.EncryptKey), (PASSWORD, info.PasswordHash));
                }
            } else {
                
                using (thandler.Begin()) {
                    //Register client
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERT }).ForTransaction(thandler), (NAME, info.Name), (DNAME, info.DisplayName), (GUID, info.Guid), (PATH, info.Path));
                    exists = await _agw.Scalar((new AdapterArgs(_key) { Query = CLIENT.EXISTS }).ForTransaction(thandler), (NAME, info.Name));
                    if (exists != null && exists is int clientId) {
                        //await _agw.Read(new AdapterArgs(_key) { Query = $@"select * from client as c where c.id = {clientId};" });
                        //Add Info
                        await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERTKEYS }).ForTransaction(thandler), (ID, clientId), (SIGNKEY, info.SigningKey), (ENCRYPTKEY, info.EncryptKey), (PASSWORD, info.PasswordHash));
                    }
                }
            }

            if (exists != null && exists.IsNumericType()) {
                //Every time a client is sucessfully done. We validate if it is present or not.
                await AddComponentCache(info);
                long.TryParse(exists.ToString(), out var id);
                return new Feedback(true) { Result = id};
            }
            return new Feedback(false, "Unable to index the client");
        }
        public async Task<IFeedback> RegisterModule(IOSSModule info) {
            if (info == null) throw new ArgumentNullException("Input Module directory info cannot be null");
            if (!info.TryValidate(out var msg)) throw new ArgumentNullException(msg);
            //We generate the hash_guid ourselves for the client.
            await EnsureValidation();

            //Check if client exists. If not throw exeception or don't register? //Send feedback.
            //var cexists = await _agw.Scalar(new AdapterArgs(_key) { Query = CLIENT.EXISTS }, (NAME, info.Client.Name));
            //if (cexists == null || !(cexists is int clientId)) throw new ArgumentException($@"Client {info.Client.Name} doesn't exist. Unable to index the module {info.DisplayName}.");
            //var mexists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS }, (NAME, info.Name), (PARENT, clientId));
            var exists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS_BY_CUID }, (CUID,info.Cuid));
            if (exists != null && exists is long mId) {
                //Module exists. .just update it.
                await _agw.NonQuery(new AdapterArgs(_key) { Query = MODULE.UPDATE }, (DNAME, info.DisplayName), (PATH, info.Path), (ID, mId));
            } else {
                var cexists = await _agw.Scalar(new AdapterArgs(_key) { Query = CLIENT.EXISTS }, (NAME, info.Client.Name));
                if (cexists == null || !(cexists is int clientId)) throw new ArgumentException($@"Client {info.Client.Name} doesn't exist. Unable to index the module {info.DisplayName}.");
                await _agw.NonQuery(new AdapterArgs(_key) { Query = MODULE.UPSERT }, (PARENT, clientId), (NAME, info.Name), (DNAME, info.DisplayName), (GUID, info.Guid), (PATH, info.Path), (CUID, info.Cuid));
            }

            exists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS_BY_CUID }, (CUID, info.Cuid));

            if (exists != null && exists.IsNumericType()) {
                //Every time a client is sucessfully done. We validate if it is present or not.
                await AddComponentCache(info,CreateModuleDBInstance);
                long.TryParse(exists.ToString(), out var id);
                return new Feedback(true, "Module Indexed.") { Result = id };
            }

            return new Feedback(false, "Unable to index the module");
        }
        public async Task<IFeedback> RegisterWorkspace(IOSSWorkspace info) {
            if (info == null) throw new ArgumentNullException("Input Module directory info cannot be null");
            if (!info.TryValidate(out var msg)) throw new ArgumentNullException(msg);
            //We generate the hash_guid ourselves for the client.
            await EnsureValidation();

            var exists = await _agw.Scalar(new AdapterArgs(_key) { Query = WORKSPACE.EXISTS_BY_CUID }, (CUID, info.Cuid));
            if (exists != null && exists is long wsId) {
                //Module exists. .just update it.
                await _agw.NonQuery(new AdapterArgs(_key) { Query = WORKSPACE.UPDATE }, (DNAME, info.DisplayName), (PATH, info.Path), (CONTROLMODE, (int)info.ControlMode), (PARSEMODE, (int)info.ParseMode),(ID, wsId));
            } else {
                var moduleCuid = OSSUtils.GenerateCuid(info.Client.Name, info.Module.Name);
                var mexists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS_BY_CUID }, (CUID, moduleCuid));
                if (mexists == null || !(mexists is int modId)) throw new ArgumentException($@"Module {info.Module.Name} doesn't exist. Unable to index the module {info.DisplayName}.");
                await _agw.NonQuery(new AdapterArgs(_key) { Query = WORKSPACE.UPSERT }, (PARENT, modId), (NAME, info.Name), (DNAME, info.DisplayName), (GUID, info.Guid), (PATH, info.Path), (CUID, info.Cuid), (CONTROLMODE, (int)info.ControlMode), (PARSEMODE, (int)info.ParseMode));
            }

            exists = await _agw.Scalar(new AdapterArgs(_key) { Query = WORKSPACE.EXISTS_BY_CUID }, (CUID, info.Cuid));

            if (exists != null && exists.IsNumericType()) {
                //Every time a client is sucessfully done. We validate if it is present or not.
                await AddComponentCache(info);
                long.TryParse(exists.ToString(), out var id);
                return new Feedback(true, "WorkSpace Indexed.") { Result = id };
            }

            return new Feedback(false, "Unable to index the module");
        }
        public async Task Validate() {
            try {
                //If the service or the db doesn't exist, we throw exception or else the system would assume that nothing is wrong. If they wish , they can still turn of the indexing.
                if (!_agw.ContainsKey(_key)) throw new ArgumentException($@"Storage Indexing service validation failure.No adapter found for the given key {_key}");
                //Next step is to find out if the database exists or not? Should we even try to check if the database exists or directly run the sql script and create the database if it doesn't exists?
                var sqlFile = Path.Combine(AssemblyUtils.GetBaseDirectory(), DB_SQL_FILE_LOCATION, DB_CORE_SQL_FILE);
                if (!File.Exists(sqlFile)) throw new ArgumentException($@"Master sql file for creating the storage DB is not found. Please check : {DB_CORE_SQL_FILE}");
                //if the file exists, then run this file against the adapter gateway but ignore the db name.
                var content = File.ReadAllText(sqlFile);
                //We know that the file itself contains "dss_core" as the schema name. Replace that with new one.
                var dbname = _agw[_key].Info?.DBName ?? DB_CORE_FALLBACK_NAME; //This is supposedly our db name.
                content = content.Replace(DB_CORE_SEARCH_TERM, dbname);
                //?? Should we run everything in one go or run as separate statements???
                await _agw.NonQuery(new AdapterArgs(_key) { ExcludeDBInConString = true, Query = content });
                isValidated = true;
            } catch (Exception ex) {
                throw ex;
            }
           
        }
        async Task AddComponentCache(IOSSDirectory info, Func<IOSSDirectory,Task> preProcess = null) {
            if (info == null) return;
            if (_idxAllDirectories.ContainsKey(info.Cuid) && _idxAllDirectories[info.Cuid] != null) return; 
            
            if (preProcess != null) {
                await preProcess(info);
            }   

            if (_idxAllDirectories.ContainsKey(info.Cuid)) {
                _idxAllDirectories.TryUpdate(info.Cuid, info, null); //Gives the schema name
            } else {
                _idxAllDirectories.TryAdd(info.Cuid, info);
            }
        }

        async Task CreateModuleDBInstance(IOSSDirectory dirInfo) {
            if (!(dirInfo is IOSSModule info)) return;
            if (string.IsNullOrWhiteSpace(info.DatabaseName)) info.DatabaseName = $@"{DB_MODULE_NAME_PREFIX}{info.Cuid}";
            //What if the CUID is changed? Should we use the guid instead? 
            //But, guid is not unique across clients. So, we use cuid.
            //So, when we create the module, we use the cuid as the database name.
            //TODO : IF A CUID IS CHANGED, THEN WE NEED TO UPDATE THE DATABASE NAME IN THE DB.
            var sqlFile = Path.Combine(AssemblyUtils.GetBaseDirectory(), DB_SQL_FILE_LOCATION, DB_CLIENT_SQL_FILE);
            if (!File.Exists(sqlFile)) throw new ArgumentException($@"Master sql for client file is not found. Please check : {DB_CLIENT_SQL_FILE}");
            //if the file exists, then run this file against the adapter gateway but ignore the db name.
            var content = File.ReadAllText(sqlFile);
            //We know that the file itself contains "dss_core" as the schema name. Replace that with new one.
            content = content.Replace(DB_CLIENT_SEARCH_TERM, info.DatabaseName);
            //?? Should we run everything in one go or run as separate statements ???
            await _agw.NonQuery(new AdapterArgs(_key) { ExcludeDBInConString = true, Query = content });
        }

        public bool TryAddInfo(IOSSDirectory dirInfo, bool replace = false) {
            if (dirInfo == null || !dirInfo.Name.AssertValue(false) || !dirInfo.Cuid.AssertValue(false)) return false;
            if (_idxAllDirectories.ContainsKey(dirInfo.Cuid)) {
                if (!replace) return false;
                return _idxAllDirectories.TryUpdate(dirInfo.Cuid, dirInfo, _idxAllDirectories[dirInfo.Cuid]);
            } else {
                return _idxAllDirectories.TryAdd(dirInfo.Cuid, dirInfo);
            }
            return true;
        }
        public bool TryGetComponentInfo<T>(string key, out T component) where T : IOSSDirectory {
            component = default(T);
            if (string.IsNullOrWhiteSpace(key) || !_idxAllDirectories.ContainsKey(key)) return false;
            var data = _idxAllDirectories[key];
            if (data == null || !(data is T)) return false;
            component = (T)data;
            return true;
        }
        
        public MariaDBIndexing(IAdapterGateway agw, string key) {
            _key = key;
            _agw = agw;
        }
    }
}
