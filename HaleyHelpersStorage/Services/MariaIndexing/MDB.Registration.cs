using Haley.Abstractions;
using Haley.Enums;
using Haley.Models;
using Haley.Utils;
using Microsoft.Extensions.Logging;
using Microsoft.VisualBasic;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using System.Runtime.CompilerServices;
using System.Security.AccessControl;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;
using System.Xml.XPath;
using static Haley.Internal.IndexingConstant;
using static Haley.Internal.IndexingQueries;
using static System.Net.Mime.MediaTypeNames;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace Haley.Utils {
    public partial class MariaDBIndexing : IDSSIndexing {
        public (long id, Guid guid) RegisterDocuments(IOSSRead request, IOSSControlled holder) {
            return RegisterDocumentsInternal(request,holder).Result;
        }
        public async Task<IFeedback> RegisterClient(IOSSClient info) {
            if (info == null) throw new ArgumentNullException("Input client directory info cannot be null");
            if (!info.TryValidate(out var msg)) throw new ArgumentException(msg);
            //We generate the hash_guid ourselves for the client.
            await EnsureValidation();

            //Do we even need to check if the client exists? Why dont' we directly upsert the values??? We need to check, because, if we try upsert, then each time , we end up with a new autogenerated id that is not consumed. So, we might end up with all ids' consumed in years. For safer side, we use upsert, also, we check if id exists and try to update separately.

            var exists = await _agw.Scalar(new AdapterArgs(_key) { Query = CLIENT.EXISTS }, (NAME, info.Name));
            var thandler = _agw.GetTransactionHandler(_key); //For both cases, update or upsert, we use inside a transaction.
            if (exists != null && exists is int cliId) {
                //Client exists. We just need to update.
                using (thandler.Begin()) {
                    //Register client
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPDATE }).ForTransaction(thandler), (DNAME, info.DisplayName), (PATH, info.Path),(ID, cliId));
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERTKEYS }).ForTransaction(thandler), (ID, cliId), (SIGNKEY, info.SigningKey), (ENCRYPTKEY, info.EncryptKey), (PASSWORD, info.PasswordHash));
                }
            } else {
                
                using (thandler.Begin()) {
                    //Register client
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERT }).ForTransaction(thandler), (NAME, info.Name), (DNAME, info.DisplayName), (GUID, info.Guid), (PATH, info.Path));
                    exists = await _agw.Scalar((new AdapterArgs(_key) { Query = CLIENT.EXISTS }).ForTransaction(thandler), (NAME, info.Name));
                    if (exists != null && exists is int clientId) {
                        //await _agw.Read(new AdapterArgs(_key) { Query = $@"select * from client as c where c.id = {clientId};" });
                        //Add Info
                        await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERTKEYS }).ForTransaction(thandler), (ID, clientId), (SIGNKEY, info.SigningKey), (ENCRYPTKEY, info.EncryptKey), (PASSWORD, info.PasswordHash));
                    }
                }
            }
            return await ValidateAndCache(CLIENT.EXISTS, "Client", info, null, (NAME, info.Name));
        }
        public async Task<IFeedback> RegisterModule(IOSSModule info) {
            if (info == null) throw new ArgumentNullException("Input Module directory info cannot be null");
            if (!info.TryValidate(out var msg)) throw new ArgumentNullException(msg);
            //We generate the hash_guid ourselves for the client.
            await EnsureValidation();

            //Check if client exists. If not throw exeception or don't register? //Send feedback.
            //var cexists = await _agw.Scalar(new AdapterArgs(_key) { Query = CLIENT.EXISTS }, (NAME, info.Client.Name));
            //if (cexists == null || !(cexists is int clientId)) throw new ArgumentException($@"Client {info.Client.Name} doesn't exist. Unable to index the module {info.DisplayName}.");
            //var mexists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS }, (NAME, info.Name), (PARENT, clientId));
            var exists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS_BY_CUID }, (CUID,info.Cuid));
            if (exists != null && exists is long mId) {
                //Module exists. .just update it.
                await _agw.NonQuery(new AdapterArgs(_key) { Query = MODULE.UPDATE }, (DNAME, info.DisplayName), (PATH, info.Path), (ID, mId));
            } else {
                var cexists = await _agw.Scalar(new AdapterArgs(_key) { Query = CLIENT.EXISTS }, (NAME, info.Client.Name));
                if (cexists == null || !(cexists is int clientId)) throw new ArgumentException($@"Client {info.Client.Name} doesn't exist. Unable to index the module {info.DisplayName}.");
                await _agw.NonQuery(new AdapterArgs(_key) { Query = MODULE.UPSERT }, (PARENT, clientId), (NAME, info.Name), (DNAME, info.DisplayName), (GUID, info.Guid), (PATH, info.Path), (CUID, info.Cuid));
            }
            return await ValidateAndCache(MODULE.EXISTS_BY_CUID, "Module", info, CreateModuleDBInstance, (CUID, info.Cuid));
        }
        public async Task<IFeedback> RegisterWorkspace(IOSSWorkspace info) {
            if (info == null) throw new ArgumentNullException("Input Module directory info cannot be null");
            if (!info.TryValidate(out var msg)) throw new ArgumentNullException(msg);
            //We generate the hash_guid ourselves for the client.
            await EnsureValidation();

            var exists = await _agw.Scalar(new AdapterArgs(_key) { Query = WORKSPACE.EXISTS_BY_CUID }, (CUID, info.Cuid));
            if (exists != null && exists is long wsId) {
                //Module exists. .just update it.
                await _agw.NonQuery(new AdapterArgs(_key) { Query = WORKSPACE.UPDATE }, (DNAME, info.DisplayName), (PATH, info.Path), (CONTROLMODE, (int)info.ControlMode), (PARSEMODE, (int)info.ParseMode),(ID, wsId));
            } else {
                var moduleCuid = OSSUtils.GenerateCuid(info.Client.Name, info.Module.Name);
                var mexists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS_BY_CUID }, (CUID, moduleCuid));
                if (mexists == null || !(mexists is int modId)) throw new ArgumentException($@"Module {info.Module.Name} doesn't exist. Unable to index the module {info.DisplayName}.");
                await _agw.NonQuery(new AdapterArgs(_key) { Query = WORKSPACE.UPSERT }, (PARENT, modId), (NAME, info.Name), (DNAME, info.DisplayName), (GUID, info.Guid), (PATH, info.Path), (CUID, info.Cuid), (CONTROLMODE, (int)info.ControlMode), (PARSEMODE, (int)info.ParseMode));
            }
            return await ValidateAndCache(WORKSPACE.EXISTS_BY_CUID, "Workspace", info, null, (CUID, info.Cuid));
        }
        public async Task Validate() {
            try {
                //If the service or the db doesn't exist, we throw exception or else the system would assume that nothing is wrong. If they wish , they can still turn of the indexing.
                if (!_agw.ContainsKey(_key)) throw new ArgumentException($@"Storage Indexing service validation failure.No adapter found for the given key {_key}");
                //Next step is to find out if the database exists or not? Should we even try to check if the database exists or directly run the sql script and create the database if it doesn't exists?
                var dbname = _agw[_key].Info?.DBName ?? DB_CORE_FALLBACK_NAME; //This is supposedly our db name.
                var exists = await _agw.Scalar(new AdapterArgs(_key) { ExcludeDBInConString = true, Query = GENERAL.SCHEMA_EXISTS }, (NAME, dbname));
                if (exists != null && exists.IsNumericType()) return;
                var sqlFile = Path.Combine(AssemblyUtils.GetBaseDirectory(), DB_SQL_FILE_LOCATION, DB_CORE_SQL_FILE);
                if (!File.Exists(sqlFile)) throw new ArgumentException($@"Master sql file for creating the storage DB is not found. Please check : {DB_CORE_SQL_FILE}");
                //if the file exists, then run this file against the adapter gateway but ignore the db name.
                var content = File.ReadAllText(sqlFile);
                //We know that the file itself contains "dss_core" as the schema name. Replace that with new one.
               
                content = content.Replace(DB_CORE_SEARCH_TERM, dbname);
                //?? Should we run everything in one go or run as separate statements???
                //if the input contains any delimiter or procedure, remove them.
                object queryContent = content;
                List<string> procedures = new();
                if (content.Contains("Delimiter", StringComparison.InvariantCultureIgnoreCase)) {
                    //Step 1 : Remove delimiter lines
                    content = Regex.Replace(content, @"DELIMITER\s+\S+", "", RegexOptions.IgnoreCase); //Remove the delimiter comments
                                                                                                       //Step 2 : Remove version-specific comments
                    content = Regex.Replace(content, @"/\*!.*?\*/;", "", RegexOptions.Singleline);
                    //Step 3 : Extract all Procedures
                    string pattern = @"CREATE\s+PROCEDURE.*?END\s*//";
                    var matches = Regex.Matches(content, pattern, RegexOptions.Singleline | RegexOptions.IgnoreCase);

                    foreach (Match match in matches) {
                        string proc = match.Value;
                        proc = proc.Replace("//", ";").Trim();
                        procedures.Add(proc);
                        content = content.Replace(match.Value, "");
                    }
                    // Step 4: Split remaining SQL by semicolon
                    queryContent = Regex.Split(content, @";\s*(?=\n|$)", RegexOptions.Multiline);
                    //queryContent = Regex.Split(content, @";\s*(?=\n|$)", RegexOptions.Multiline);
                }

                var handler = _agw.GetTransactionHandler(_key);
                using (handler.Begin(true)) {
                    await _agw.NonQuery(new AdapterArgs(_key) { ExcludeDBInConString = true, Query = queryContent }.ForTransaction(handler));
                    if (procedures.Count > 0) {
                        await _agw.NonQuery(new AdapterArgs(_key) { ExcludeDBInConString = true, Query = procedures.ToArray() }.ForTransaction(handler));
                    }
                }
                isValidated = true;
            } catch (Exception ex) {
                throw ex;
            }
           
        }
    }
}
